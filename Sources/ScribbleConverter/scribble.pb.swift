// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: scribble.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  //// The vertical coordinate.
  var y: Double = 0

  //// The pressure for this point.
  var p: Double = 0

  //// The altitude for this point.
  var altitude: Double = 0

  //// The azimuth for this point.
  var azimuth: Double = 0

  //// The opacity for this point.
  var opacity: Double = 0

  //// The sizeV for this point.
  var size: [Double] = []

  //// The timestamp for this point.
  var deprecatedTimestamp: Double = 0

  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StrokePoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var point: Point {
    get {return _storage._point ?? Point()}
    set {_uniqueStorage()._point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  var hasPoint: Bool {return _storage._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  mutating func clearPoint() {_uniqueStorage()._point = nil}

  var vector: Point {
    get {return _storage._vector ?? Point()}
    set {_uniqueStorage()._vector = newValue}
  }
  /// Returns true if `vector` has been explicitly set.
  var hasVector: Bool {return _storage._vector != nil}
  /// Clears the value of `vector`. Subsequent reads from it will return its default value.
  mutating func clearVector() {_uniqueStorage()._vector = nil}

  var distance: Double {
    get {return _storage._distance}
    set {_uniqueStorage()._distance = newValue}
  }

  var runningLength: Double {
    get {return _storage._runningLength}
    set {_uniqueStorage()._runningLength = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StrokeOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The base size (diameter) of the stroke.
  var size: Double = 0

  //// The effect of pressure on the stroke's size.
  var thinning: Double = 0

  //// Controls the density of points along the stroke's edges.
  var smoothing: Double = 0

  //// Controls the level of variation allowed in the input points.
  var streamline: Double = 0

  /// The distance to taper the front of the stroke.
  var taperStart: Double = 0

  /// Whether to add a cap to the start of the stroke.
  var capStart: Bool = false

  /// The distance to taper the end of the stroke.
  var taperEnd: Double = 0

  /// Whether to add a cap to the end of the stroke.
  var capEnd: Bool = false

  /// Whether to simulate pressure or use the point's provided pressures.
  var simulatePressure: Bool = false

  /// Whether the line is complete.
  var isComplete: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stroke {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var points: [Point] = []

  var color: UInt32 = 0

  var ink: String = String()

  var createdAt: String = String()

  var options: StrokeOptions {
    get {return _options ?? StrokeOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _options: StrokeOptions? = nil
}

struct Scribble {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Double {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: Double {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var strokes: [Stroke] = []

  var updatedAt: String = String()

  var createdAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _width: Double? = nil
  fileprivate var _height: Double? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Point: @unchecked Sendable {}
extension StrokePoint: @unchecked Sendable {}
extension StrokeOptions: @unchecked Sendable {}
extension Stroke: @unchecked Sendable {}
extension Scribble: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Point"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "p"),
    4: .same(proto: "altitude"),
    5: .same(proto: "azimuth"),
    6: .same(proto: "opacity"),
    7: .same(proto: "size"),
    8: .standard(proto: "deprecated_timestamp"),
    9: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.p) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.azimuth) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.opacity) }()
      case 7: try { try decoder.decodeRepeatedDoubleField(value: &self.size) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.deprecatedTimestamp) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.p != 0 {
      try visitor.visitSingularDoubleField(value: self.p, fieldNumber: 3)
    }
    if self.altitude != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 4)
    }
    if self.azimuth != 0 {
      try visitor.visitSingularDoubleField(value: self.azimuth, fieldNumber: 5)
    }
    if self.opacity != 0 {
      try visitor.visitSingularDoubleField(value: self.opacity, fieldNumber: 6)
    }
    if !self.size.isEmpty {
      try visitor.visitPackedDoubleField(value: self.size, fieldNumber: 7)
    }
    if self.deprecatedTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.deprecatedTimestamp, fieldNumber: 8)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Point, rhs: Point) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.p != rhs.p {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.azimuth != rhs.azimuth {return false}
    if lhs.opacity != rhs.opacity {return false}
    if lhs.size != rhs.size {return false}
    if lhs.deprecatedTimestamp != rhs.deprecatedTimestamp {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StrokePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StrokePoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "vector"),
    3: .same(proto: "distance"),
    4: .same(proto: "runningLength"),
  ]

  fileprivate class _StorageClass {
    var _point: Point? = nil
    var _vector: Point? = nil
    var _distance: Double = 0
    var _runningLength: Double = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _point = source._point
      _vector = source._vector
      _distance = source._distance
      _runningLength = source._runningLength
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._point) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._vector) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._distance) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._runningLength) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._point {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._vector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._distance != 0 {
        try visitor.visitSingularDoubleField(value: _storage._distance, fieldNumber: 3)
      }
      if _storage._runningLength != 0 {
        try visitor.visitSingularDoubleField(value: _storage._runningLength, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StrokePoint, rhs: StrokePoint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._point != rhs_storage._point {return false}
        if _storage._vector != rhs_storage._vector {return false}
        if _storage._distance != rhs_storage._distance {return false}
        if _storage._runningLength != rhs_storage._runningLength {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StrokeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StrokeOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "thinning"),
    3: .same(proto: "smoothing"),
    4: .same(proto: "streamline"),
    5: .same(proto: "taperStart"),
    6: .same(proto: "capStart"),
    7: .same(proto: "taperEnd"),
    8: .same(proto: "capEnd"),
    9: .same(proto: "simulatePressure"),
    10: .same(proto: "isComplete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.size) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.thinning) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.smoothing) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.streamline) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.taperStart) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.capStart) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.taperEnd) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.capEnd) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.simulatePressure) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.isComplete) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularDoubleField(value: self.size, fieldNumber: 1)
    }
    if self.thinning != 0 {
      try visitor.visitSingularDoubleField(value: self.thinning, fieldNumber: 2)
    }
    if self.smoothing != 0 {
      try visitor.visitSingularDoubleField(value: self.smoothing, fieldNumber: 3)
    }
    if self.streamline != 0 {
      try visitor.visitSingularDoubleField(value: self.streamline, fieldNumber: 4)
    }
    if self.taperStart != 0 {
      try visitor.visitSingularDoubleField(value: self.taperStart, fieldNumber: 5)
    }
    if self.capStart != false {
      try visitor.visitSingularBoolField(value: self.capStart, fieldNumber: 6)
    }
    if self.taperEnd != 0 {
      try visitor.visitSingularDoubleField(value: self.taperEnd, fieldNumber: 7)
    }
    if self.capEnd != false {
      try visitor.visitSingularBoolField(value: self.capEnd, fieldNumber: 8)
    }
    if self.simulatePressure != false {
      try visitor.visitSingularBoolField(value: self.simulatePressure, fieldNumber: 9)
    }
    if self.isComplete != false {
      try visitor.visitSingularBoolField(value: self.isComplete, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StrokeOptions, rhs: StrokeOptions) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.thinning != rhs.thinning {return false}
    if lhs.smoothing != rhs.smoothing {return false}
    if lhs.streamline != rhs.streamline {return false}
    if lhs.taperStart != rhs.taperStart {return false}
    if lhs.capStart != rhs.capStart {return false}
    if lhs.taperEnd != rhs.taperEnd {return false}
    if lhs.capEnd != rhs.capEnd {return false}
    if lhs.simulatePressure != rhs.simulatePressure {return false}
    if lhs.isComplete != rhs.isComplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stroke: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Stroke"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "color"),
    3: .same(proto: "ink"),
    4: .same(proto: "createdAt"),
    5: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.color) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ink) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if self.color != 0 {
      try visitor.visitSingularUInt32Field(value: self.color, fieldNumber: 2)
    }
    if !self.ink.isEmpty {
      try visitor.visitSingularStringField(value: self.ink, fieldNumber: 3)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 4)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stroke, rhs: Stroke) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.color != rhs.color {return false}
    if lhs.ink != rhs.ink {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Scribble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Scribble"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .unique(proto: "strokes", json: "lines"),
    4: .same(proto: "updatedAt"),
    5: .same(proto: "createdAt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._width) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._height) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.strokes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._width {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    if !self.strokes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.strokes, fieldNumber: 3)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 4)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Scribble, rhs: Scribble) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs.strokes != rhs.strokes {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
